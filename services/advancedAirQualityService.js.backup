/**
 * @fileoverview Servicio avanzado de monitoreo de calidad del aire
 * Implementa metodología detallada NASA/Copernicus:
 * - ECMWF/CAMS para PM2.5, AOD550, SO₂, CO
 * - Sentinel-5P TROPOMI para NO₂
 * - Filtrado de nubes y calidad
 * - Análisis de exposición poblacional
 * - Umbrales de alerta por contaminante
 * 
 * @module services/advancedAirQualityService
 */

const ee = require('@google/earthengine');

class AdvancedAirQualityService {
  constructor() {
    this.initialized = false;
    
    // Umbrales de alerta según estándares OMS y EPA
    this.thresholds = {
      no2: {
        low: 50,      // μmol/m² (buena calidad)
        medium: 100,   // μmol/m² (moderada)
        high: 150,     // μmol/m² (mala)
        critical: 200  // μmol/m² (muy mala)
      },
      pm25: {
        low: 15,       // μg/m³ (OMS 2021)
        medium: 35,    // μg/m³ (EPA)
        high: 55,      // μg/m³
        critical: 150  // μg/m³
      },
      aod550: {
        low: 0.1,      // Aerosol Optical Depth a 550nm
        medium: 0.3,
        high: 0.5,
        critical: 1.0
      },
      so2: {
        low: 20,       // ppb
        medium: 75,
        high: 185,
        critical: 304
      },
      co: {
        low: 4.4,      // ppm
        medium: 9.4,
        high: 12.4,
        critical: 15.4
      }
    };
  }

  async initialize() {
    if (!this.initialized) {
      try {
        await ee.Number(1).getInfo();
        this.initialized = true;
        console.log('✅ AdvancedAirQualityService inicializado');
      } catch (error) {
        console.error('❌ Error inicializando AdvancedAirQualityService:', error);
        throw error;
      }
    }
  }

  /**
   * Análisis completo de calidad del aire con Sentinel-5P y CAMS
   * 
   * @param {Object} params - Parámetros de análisis
   * @param {ee.Geometry} params.geometry - Geometría del área
   * @param {String} params.startDate - Fecha inicial (YYYY-MM-DD)
   * @param {String} params.endDate - Fecha final (YYYY-MM-DD)
   * @param {Number} params.cloudThreshold - Umbral de fracción de nubes (default: 0.5)
   * @returns {Promise<Object>} Métricas de calidad del aire y exposición
   */
  async analyzeAirQuality(params) {
    await this.initialize();

    const {
      geometry,
      startDate = '2024-09-01',
      endDate = '2024-09-30',
      cloudThreshold = 0.5
    } = params;

    try {
      const aoi = ee.Geometry(geometry);

      console.log(`[Air Quality] Analizando período ${startDate} a ${endDate}`);

      // 1. NO₂ de Sentinel-5P TROPOMI (usar dataset OFFL para mayor cobertura histórica)
      const no2Collection = ee.ImageCollection('COPERNICUS/S5P/OFFL/L3_NO2')
        .filterDate(startDate, endDate)
        .filterBounds(aoi);

      // VALIDACIÓN: Verificar que hay imágenes disponibles
      const no2Size = await no2Collection.size().getInfo();
      console.log(`[Air Quality] Imágenes NO2 disponibles: ${no2Size}`);
      
      if (no2Size === 0) {
        return {
          success: false,
          error: `No hay datos de NO2 (Sentinel-5P) disponibles para el área y período especificado (${startDate} a ${endDate})`,
          suggestion: 'Sentinel-5P comenzó operaciones en 2018. Intente con fechas desde 2019 en adelante'
        };
      }

      // Seleccionar solo NO2 troposférico
      const no2Band = no2Collection.select('tropospheric_NO2_column_number_density');
      
      // Convertir a μmol/m² (multiplicar por 1e6)
      const no2Mean = no2Band.mean().multiply(1e6).rename('NO2');

      // 2. AOD (Aerosol Optical Depth) - MODIS MAIAC MCD19A2 según metodología NASA
      // Dataset: MODIS/061/MCD19A2_GRANULES - AOD diario a 1km
      // Banda: Optical_Depth_047 (AOD a 470nm, se aproxima a 550nm)
      const aodCollection = ee.ImageCollection('MODIS/061/MCD19A2_GRANULES')
        .filterDate(startDate, endDate)
        .filterBounds(aoi)
        .select('Optical_Depth_047'); // AOD a 470nm (proxy para 550nm)

      // VALIDACIÓN: Verificar disponibilidad AOD
      const aodSize = await aodCollection.size().getInfo();
      console.log(`[Air Quality] Imágenes AOD (MODIS MAIAC) disponibles: ${aodSize}`);
      
      // Calcular AOD medio (escalar: valor raw * 0.001 según documentación MAIAC)
      const aodMean = aodSize > 0 
        ? aodCollection.mean().multiply(0.001).rename('AOD')
        : ee.Image.constant(0).rename('AOD');

      // 3. PM2.5 - Usar Sentinel-5P Aerosol Index como proxy si disponible
      const pm25Collection = ee.ImageCollection('COPERNICUS/S5P/OFFL/L3_AER_AI')
        .filterDate(startDate, endDate)
        .filterBounds(aoi)
        .select('absorbing_aerosol_index');

      const pm25Size = await pm25Collection.size().getInfo();
      console.log(`[Air Quality] Imágenes PM2.5 (Aerosol Index) disponibles: ${pm25Size}`);

      const pm25Mean = pm25Size > 0
        ? pm25Collection.mean().rename('PM25_proxy')
        : ee.Image.constant(0).rename('PM25_proxy');

      // 3. Estadísticas por contaminante (NO2, AOD, PM25)
      const stats = no2Mean
        .addBands(aodMean)
        .addBands(pm25Mean)
        .reduceRegion({
          reducer: ee.Reducer.mean()
            .combine(ee.Reducer.min(), '', true)
            .combine(ee.Reducer.max(), '', true)
            .combine(ee.Reducer.stdDev(), '', true),
          geometry: aoi,
          scale: 1000,
          maxPixels: 1e13,
          bestEffort: true
        });

      // 4. Generar mapas
      const no2MapInfo = no2Mean.getMap({
        min: 0,
        max: 200,
        palette: ['green', 'yellow', 'orange', 'red', 'purple']
      });

      const aodMapInfo = aodMean.getMap({
        min: 0,
        max: 1,
        palette: ['white', 'lightblue', 'yellow', 'orange', 'red', 'darkred']
      });

      const pm25MapInfo = pm25Mean.getMap({
        min: -2,
        max: 5,
        palette: ['blue', 'white', 'yellow', 'orange', 'red']
      });

      // 5. Obtener valores
      const statsInfo = await stats.getInfo();

      // 6. Clasificar niveles de calidad del aire
      const airQualityIndex = this._calculateAQI({
        no2: statsInfo.NO2_mean || 0,
        aod: statsInfo.AOD_mean || 0,
        pm25: statsInfo.PM25_proxy_mean || 0
      });

      console.log(`[Air Quality] AQI calculado: ${airQualityIndex}, NO2: ${(statsInfo.NO2_mean || 0).toFixed(2)} μmol/m², AOD: ${(statsInfo.AOD_mean || 0).toFixed(3)}`);

      return {
        success: true,
        summary: {
          period: { startDate, endDate },
          imagesUsed: { 
            no2: no2Size, 
            aod: aodSize,
            pm25: pm25Size
          },
          airQualityIndex: airQualityIndex,
          qualityLevel: this._getAQILevel(airQualityIndex)
        },
        data: {
          pollutants: {
            no2: {
              mean: parseFloat((statsInfo.NO2_mean || 0).toFixed(2)),
              min: parseFloat((statsInfo.NO2_min || 0).toFixed(2)),
              max: parseFloat((statsInfo.NO2_max || 0).toFixed(2)),
              stdDev: parseFloat((statsInfo.NO2_stdDev || 0).toFixed(2)),
              unit: 'μmol/m²',
              level: this._classifyLevel(statsInfo.NO2_mean || 0, this.thresholds.no2),
              source: 'Sentinel-5P TROPOMI',
              description: 'Dióxido de Nitrógeno troposférico'
            },
            aod: {
              mean: parseFloat((statsInfo.AOD_mean || 0).toFixed(3)),
              min: parseFloat((statsInfo.AOD_min || 0).toFixed(3)),
              max: parseFloat((statsInfo.AOD_max || 0).toFixed(3)),
              stdDev: parseFloat((statsInfo.AOD_stdDev || 0).toFixed(3)),
              unit: 'adimensional',
              level: this._classifyLevel(statsInfo.AOD_mean || 0, this.thresholds.aod550),
              source: 'MODIS MAIAC MCD19A2',
              description: 'Profundidad Óptica de Aerosoles a 470nm',
              interpretation: statsInfo.AOD_mean < 0.1 ? 'Cielo claro' : 
                             statsInfo.AOD_mean < 0.3 ? 'Aerosoles moderados' :
                             statsInfo.AOD_mean < 0.5 ? 'Aerosoles altos' : 'Aerosoles muy densos'
            },
            pm25_proxy: {
              mean: parseFloat((statsInfo.PM25_proxy_mean || 0).toFixed(2)),
              min: parseFloat((statsInfo.PM25_proxy_min || 0).toFixed(2)),
              max: parseFloat((statsInfo.PM25_proxy_max || 0).toFixed(2)),
              unit: 'Aerosol Index',
              source: 'Sentinel-5P TROPOMI',
              description: 'Índice de Aerosoles Absorbentes (proxy PM2.5)',
              note: 'Valores positivos indican presencia de aerosoles absorbentes (polvo, humo)'
            }
          },
          maps: {
            no2: {
              urlFormat: no2MapInfo.urlFormat,
              description: 'Concentración de NO₂ troposférico',
              legend: {
                min: 0,
                max: 200,
                unit: 'μmol/m²',
                colors: ['verde (limpio)', 'amarillo', 'naranja', 'rojo', 'morado (alto)']
              }
            },
            aod: {
              urlFormat: aodMapInfo.urlFormat,
              description: 'Profundidad Óptica de Aerosoles (AOD)',
              legend: {
                min: 0,
                max: 1,
                unit: 'adimensional',
                colors: ['blanco (claro)', 'azul claro', 'amarillo', 'naranja', 'rojo', 'rojo oscuro (denso)'],
                interpretation: '<0.1: cielo claro, 0.1-0.3: moderado, 0.3-0.5: alto, >0.5: muy denso'
              }
            },
            pm25_proxy: {
              urlFormat: pm25MapInfo.urlFormat,
              description: 'Índice de Aerosoles Absorbentes (proxy PM2.5)',
              legend: {
                min: -2,
                max: 5,
                unit: 'Aerosol Index',
                colors: ['azul (limpio)', 'blanco', 'amarillo', 'naranja', 'rojo (contaminado)']
              }
            }
          },
          recommendations: this._generateRecommendations({
            no2: statsInfo.NO2_mean || 0,
            aod: statsInfo.AOD_mean || 0,
            aqi: airQualityIndex
          }),
          metadata: {
            startDate,
            endDate,
            area: geometry,
            datasets: [
              'COPERNICUS/S5P/OFFL/L3_NO2 (Sentinel-5P TROPOMI)',
              'MODIS/061/MCD19A2_GRANULES (MODIS MAIAC AOD)',
              'COPERNICUS/S5P/OFFL/L3_AER_AI (Aerosol Index)'
            ],
            methodology: 'Basado en metodología NASA Worldview y GIBS',
            references: {
              aod: 'AOD MAIAC combina algoritmos Dark Target y Deep Blue',
              no2: 'NO₂ troposférico de TROPOMI con resolución ~7km',
              pm25: 'Aerosol Index como indicador proxy de partículas'
            },
            resolution: {
              no2: '~7 km (TROPOMI)',
              aod: '1 km (MODIS MAIAC)',
              pm25_proxy: '~7 km (TROPOMI)'
            },
            note: 'Análisis simplificado. AOD según metodología NASA/GIBS. PM2.5 es aproximación mediante Aerosol Index.'
          }
        }
      };

    } catch (error) {
      console.error('Error en analyzeAirQuality:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Calcula AQI simplificado basado en múltiples contaminantes
   */
  _calculateAQI(pollutants) {
    const { no2, aod, pm25 } = pollutants;
    
    // Normalizar cada contaminante a escala 0-500 AQI
    const no2AQI = this._normalizeToAQI(no2 || 0, [0, 50, 100, 150, 200], [0, 50, 100, 150, 200]);
    const aodAQI = this._normalizeToAQI(aod || 0, [0, 0.1, 0.3, 0.5, 1.0], [0, 50, 100, 150, 200]);
    const pm25AQI = this._normalizeToAQI(pm25 || 0, [-2, 0, 1, 3, 5], [0, 50, 100, 150, 200]);
    
    // Tomar el máximo (el peor contaminante)
    return Math.round(Math.max(no2AQI, aodAQI, pm25AQI));
  }

  /**
   * Normaliza valor a escala AQI
   */
  _normalizeToAQI(value, breakpoints, aqiValues) {
    for (let i = 0; i < breakpoints.length - 1; i++) {
      if (value >= breakpoints[i] && value <= breakpoints[i + 1]) {
        const fraction = (value - breakpoints[i]) / (breakpoints[i + 1] - breakpoints[i]);
        return aqiValues[i] + fraction * (aqiValues[i + 1] - aqiValues[i]);
      }
    }
    return value > breakpoints[breakpoints.length - 1] ? aqiValues[aqiValues.length - 1] : aqiValues[0];
  }

  /**
   * Obtiene nivel de calidad según AQI
   */
  _getAQILevel(aqi) {
    if (aqi <= 50) return 'Buena';
    if (aqi <= 100) return 'Moderada';
    if (aqi <= 150) return 'Dañina para grupos sensibles';
    if (aqi <= 200) return 'Dañina';
    if (aqi <= 300) return 'Muy dañina';
    return 'Peligrosa';
  }

  /**
   * Genera recomendaciones basadas en contaminantes
   */
  _generateRecommendations(data) {
    const recommendations = [];
    const { no2, aod, aqi } = data;

    if (aqi > 150) {
      recommendations.push({
        priority: 'urgent',
        action: 'Restricción de actividades al aire libre',
        target: 'Población general',
        reason: `AQI ${aqi} - Calidad del aire dañina`,
        measures: ['Evitar ejercicio al aire libre', 'Usar mascarillas N95', 'Cerrar ventanas']
      });
    }

    if (no2 > 150) {
      recommendations.push({
        priority: 'high',
        action: 'Control de emisiones vehiculares',
        target: 'Autoridades de tránsito',
        reason: `NO₂ elevado: ${no2.toFixed(1)} μmol/m²`,
        measures: ['Restricción vehicular', 'Promover transporte público', 'Monitoreo continuo']
      });
    }

    if (aod > 0.5) {
      recommendations.push({
        priority: 'high',
        action: 'Alerta por aerosoles densos',
        target: 'Población sensible',
        reason: `AOD ${aod.toFixed(2)} - Aerosoles muy densos`,
        measures: ['Vigilar síntomas respiratorios', 'Consultar médico si hay molestias', 'Evitar exposición prolongada']
      });
    }

    if (aqi <= 50) {
      recommendations.push({
        priority: 'low',
        action: 'Mantener monitoreo regular',
        target: 'Autoridades ambientales',
        reason: 'Calidad del aire buena',
        measures: ['Continuar vigilancia', 'Actualizar datos diarios']
      });
    }

    return recommendations;
  }



  /**
   * Genera recomendaciones simples basadas en AQI (legacy - puede eliminarse)
   * @private
   */
      }

    return recommendations;
  }

  /**
   * Clasifica nivel según umbrales
   */
  _classifyLevel(value, thresholds) {
    if (value <= thresholds.low) return 'Bajo';
    if (value <= thresholds.medium) return 'Moderado';
    if (value <= thresholds.high) return 'Alto';
    return 'Crítico';
  }

  /**
   * Análisis temporal de calidad del aire (series de tiempo)
   * 
   * @param {Object} params - Parámetros
   * @param {ee.Geometry} params.geometry - Geometría del área
   * @param {Array<Number>} params.years - Años a analizar [2020, 2021, 2022, ...]
   * @returns {Promise<Object>} Series temporales por contaminante
   */
  async analyzeTemporalTrends(params) {
    await this.initialize();

    const { geometry, years } = params;
    
    // Validar que years sea un array
    if (!Array.isArray(years)) {
      throw new Error('Parameter "years" must be an array');
    }

    const results = [];

    // Analizar cada año completo
    for (const year of years) {
      const startDate = `${year}-01-01`;
      const endDate = `${year}-12-31`;

      try {
        const analysis = await this.analyzeAirQuality({
          geometry,
          startDate,
          endDate
        });

        if (analysis.success && analysis.data) {
          results.push({
            year: year,
            aqi: analysis.summary.airQualityIndex || 0,
            no2: analysis.data.pollutants.no2.mean,
            aod: analysis.data.pollutants.aod.mean,
            pm25_proxy: analysis.data.pollutants.pm25_proxy.mean
          });
        }
      } catch (error) {
        console.warn(`Error analyzing year ${year}:`, error.message);
        // Continuar con el siguiente año
      }
    }

    // Validar que tengamos resultados
    if (results.length === 0) {
      return {
        success: true,
        data: {
          timeSeries: [],
          trend: null,
          summary: {
            avgAQI: 0,
            maxAQI: 0,
            minAQI: 0
          },
          interpretation: 'No se obtuvieron datos para los años solicitados'
        }
      };
    }

    return {
      success: true,
      data: {
        timeSeries: results,
        trend: this._calculateTrend(results, 'aqi'),
        summary: {
          avgAQI: Math.round(results.reduce((sum, r) => sum + r.aqi, 0) / results.length),
          maxAQI: Math.max(...results.map(r => r.aqi)),
          minAQI: Math.min(...results.map(r => r.aqi))
        }
      }
    };
  }

  /**
   * Calcula tendencia simple
   * @private
   */
  _calculateTrend(data, field) {
    if (data.length < 2) return null;

    const n = data.length;
    const sumX = data.reduce((sum, d, i) => sum + i, 0);
    const sumY = data.reduce((sum, d) => sum + d[field], 0);
    const sumXY = data.reduce((sum, d, i) => sum + i * d[field], 0);
    const sumX2 = data.reduce((sum, d, i) => sum + i * i, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

    return {
      slope,
      direction: slope > 1 ? 'worsening' : slope < -1 ? 'improving' : 'stable'
    };
  }
}

module.exports = new AdvancedAirQualityService();

  /**
   * Análisis temporal de calidad del aire (series de tiempo)
   * 
   * @param {Object} params - Parámetros
   * @param {ee.Geometry} params.geometry - Geometría del área
   * @param {Array<Number>} params.years - Años a analizar [2020, 2021, 2022, ...]
   * @returns {Promise<Object>} Series temporales por contaminante
   */
  async analyzeTemporalTrends(params) {

  /**
   * Calcula Índice de Calidad del Aire (AQI) combinado
   * @private
   */
  _calculateAQI(values) {
    const { no2, pm25, aod } = values;

    // Normalizar cada valor (0-100 escala)
    const no2Score = Math.min(100, (no2 / this.thresholds.no2.critical) * 100);
    const pm25Score = Math.min(100, (pm25 / this.thresholds.pm25.critical) * 100);
    const aodScore = Math.min(100, (aod / this.thresholds.aod550.critical) * 100);

    // Promedio ponderado (PM2.5 tiene mayor peso)
    const aqi = (pm25Score * 0.5) + (no2Score * 0.3) + (aodScore * 0.2);

    let level, color, description;

    if (aqi <= 25) {
      level = 'excellent';
      color = 'green';
      description = 'Calidad del aire excelente';
    } else if (aqi <= 50) {
      level = 'good';
      color = 'yellow';
      description = 'Calidad del aire buena';
    } else if (aqi <= 75) {
      level = 'moderate';
      color = 'orange';
      description = 'Calidad del aire moderada - grupos sensibles en riesgo';
    } else {
      level = 'poor';
      color = 'red';
      description = 'Calidad del aire mala - toda la población en riesgo';
    }

    return {
      value: Math.round(aqi),
      level,
      color,
      description,
      components: {
        pm25: Math.round(pm25Score),
        no2: Math.round(no2Score),
        aod: Math.round(aodScore)
      }
    };
  }

  /**
   * Clasifica nivel de un contaminante
   * @private
   */
  _classifyLevel(value, thresholds) {
    if (value <= thresholds.low) return 'low';
    if (value <= thresholds.medium) return 'medium';
    if (value <= thresholds.high) return 'high';
    return 'critical';
  }

  /**
   * Identifica el contaminante con mayor concentración relativa
   * @private
   */
  _identifyPrimaryConcern(values) {
    const { no2, pm25, aod } = values;
    
    const scores = {
      no2: (no2 / this.thresholds.no2.critical) * 100,
      pm25: (pm25 / this.thresholds.pm25.critical) * 100,
      aod: (aod / this.thresholds.aod550.critical) * 100
    };

    const max = Math.max(scores.no2, scores.pm25, scores.aod);
    
    if (scores.pm25 === max) return 'PM2.5 (Material Particulado)';
    if (scores.no2 === max) return 'NO₂ (Dióxido de Nitrógeno)';
    return 'AOD (Aerosoles)';
  }

  /**
   * Genera recomendaciones basadas en AQI y exposición
   * @private
   */
  _generateRecommendations(aqi, exposure) {
    const recommendations = [];

    if (aqi.level === 'poor' || aqi.level === 'moderate') {
      recommendations.push({
        priority: 'high',
        target: 'Población general',
        action: 'Reducir actividades al aire libre',
        reason: `AQI: ${aqi.value} - ${aqi.description}`
      });
    }

    if (exposure.percentage > 25) {
      recommendations.push({
        priority: 'high',
        target: 'Autoridades',
        action: 'Implementar restricciones vehiculares',
        reason: `${exposure.percentage}% de población expuesta a múltiples contaminantes`
      });
    }

    if (aqi.components.pm25 > 50) {
      recommendations.push({
        priority: 'medium',
        target: 'Grupos sensibles',
        action: 'Usar mascarillas N95 al aire libre',
        reason: 'Niveles elevados de PM2.5'
      });
    }

    if (recommendations.length === 0) {
      recommendations.push({
        priority: 'low',
        target: 'Población general',
        action: 'Continuar con actividades normales',
        reason: 'Calidad del aire en niveles aceptables'
      });
    }

    return recommendations;
  }

  /**
   * Análisis temporal de calidad del aire (series de tiempo)
   * 
   * @param {Object} params - Parámetros
   * @param {ee.Geometry} params.geometry - Geometría del área
   * @param {Array<Number>} params.years - Años a analizar [2020, 2021, 2022, ...]
   * @returns {Promise<Object>} Series temporales por contaminante
   */
  async analyzeTemporalTrends(params) {
    await this.initialize();

    const { geometry, years } = params;
    
    // Validar que years sea un array
    if (!Array.isArray(years)) {
      throw new Error('Parameter "years" must be an array');
    }

    const results = [];

    // Analizar cada año completo
    for (const year of years) {
      const startDate = `${year}-01-01`;
      const endDate = `${year}-12-31`;

      try {
        const analysis = await this.analyzeAirQuality({
          geometry,
          startDate,
          endDate
        });

        if (analysis.success && analysis.data) {
          results.push({
            year: year,
            aqi: analysis.data.airQualityIndex.value,
            no2: analysis.data.pollutants.no2.mean,
            pm25: analysis.data.pollutants.pm25.mean,
            aod: analysis.data.pollutants.aod550.mean,
            exposedPopulation: analysis.data.exposure.exposedPopulation
          });
        }
      } catch (error) {
        console.warn(`Error analyzing year ${year}:`, error.message);
        // Continuar con el siguiente año
      }
    }

    // Validar que tengamos resultados
    if (results.length === 0) {
      return {
        success: true,
        data: {
          timeSeries: [],
          trend: null,
          summary: {
            avgAQI: 0,
            maxAQI: 0,
            minAQI: 0
          },
          interpretation: 'No se obtuvieron datos para los años solicitados'
        }
      };
    }

    return {
      success: true,
      data: {
        timeSeries: results,
        trend: this._calculateTrend(results, 'aqi'),
        summary: {
          avgAQI: Math.round(results.reduce((sum, r) => sum + r.aqi, 0) / results.length),
          maxAQI: Math.max(...results.map(r => r.aqi)),
          minAQI: Math.min(...results.map(r => r.aqi))
        }
      }
    };
  }

  /**
   * Calcula tendencia simple
   * @private
   */
  _calculateTrend(data, field) {
    if (data.length < 2) return null;

    const n = data.length;
    const sumX = data.reduce((sum, d, i) => sum + i, 0);
    const sumY = data.reduce((sum, d) => sum + d[field], 0);
    const sumXY = data.reduce((sum, d, i) => sum + i * d[field], 0);
    const sumX2 = data.reduce((sum, d, i) => sum + i * i, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

    return {
      slope,
      direction: slope > 1 ? 'worsening' : slope < -1 ? 'improving' : 'stable'
    };
  }
}

module.exports = new AdvancedAirQualityService();
